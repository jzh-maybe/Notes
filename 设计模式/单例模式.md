# 单例模式 Singleton Pattern

## 意图
确保一个类只有一个实例，并提供该实例的全局访问点。可以减少内存地开销，尤其是一个全局使用的类频繁地创建和销毁，节省系统资源。
## 实现
使用一个私有构造方法、一个私有静态变量和一个公有静态方法来实现。
私有构造方法确保不能直接通过构造方法来创建对象实例，只能通过公有静态方法返回唯一私有静态变量。
### I.懒汉式(线程不安全) 
在这种实现中，私有静态变量instance被延迟实例化。这个实现在多线程环境下是不安全的，如果多个线程同时进入`if(instance == null)`，并且此时`instance`为`null`，那么会有多个线程执行`instance = new Singleton();`语句，将会导致`instance`被实例化多次。
```
public class Singleton {

    private static Singleton instance;

    private Singleton() {}
	
    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;		
    }
}
```
### II.懒汉式(线程安全)
只需要对`getInstance()`方法加锁，那么在一个时间点只能有一个线程能够进入该方法，避免了实例化多次`instance`。**但是当一个线程进入该方法后，其他试图进入该方法的线程都必须等待，这会导致线程阻塞时间过长，该方法有性能问题，不推荐使用。**
```
public class Singleton {

    private static Singleton instance;

    private Singleton() {}
	
    public static synchronized Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;		
    }
}
```
### III.饿汉式(线程安全）
线程不安全问题主要是由于`instance`被实例化多次，采取直接实例化的方式就不会产生线程不安全问题。
直接实例化的方式丢失了延迟实例化带来的节约资源的好处。
```
private static Singleton instance = new Singleton();
```
### IV.双重校验锁(线程安全)
加锁操作只需要对实例化那部分的代码进行，当`instance`没有被实例化时，才需要加锁。
```
public class Singleton {
    private volatile static Singleton instance;
    private Singleton() {}

    public static Singleton getInstance() {
        if(instance == null) {
            synchronized(Singleton.class) {
                if(instance == null) {
                    instance = new Instance();
                }
            }   
        }
        return instance;
    }
}
```
在上述代码中，如果只使用一条`if`语句，那么在`instance==null`的情况下，如果有两个线程都执行了`if`语句，那么这两个线程都会进入`if`语句块内。虽然在语句块内有加锁操作，但两个线程都会执行`instance=new Singlrton();`，只是先后的问题，那么会进行两次实例化，因此必须使用双重校验锁。
### V.静态内部类实现












