# 单例模式 Singleton Pattern

## 意图
确保一个类只有一个实例，并提供该实例的全局访问点。可以减少内存地开销，尤其是一个全局使用的类频繁地创建和销毁，节省系统资源。
## 实现
使用一个私有构造方法、一个私有静态变量和一个公有静态方法来实现。
私有构造方法确保不能直接通过构造方法来创建对象实例，只能通过公有静态方法返回唯一私有静态变量。
### I.懒汉式(线程不安全) 
在这种实现中，私有静态变量instance被延迟实例化。这个实现在多线程环境下是不安全的，如果多个线程同时进入`if(instance == null)`，并且此时`instance`为`null`，那么会有多个线程执行`instance = new Singleton();`语句，将会导致`instance`被实例化多次。
```
public class Singleton {

    private static Singleton instance;

    private Singleton() {}
	
    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;		
    }
}
```
### II.懒汉式(线程安全)
只需要对`getInstance()`方法加锁，那么在一个时间点只能有一个线程能够进入该方法，避免了实例化多次`instance`。**但是当一个线程进入该方法后，其他试图进入该方法的线程都必须等待，这会导致线程阻塞时间过长，该方法有性能问题，不推荐使用。**
```
public class Singleton {

    private static Singleton instance;

    private Singleton() {}
	
    public static synchronized Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;		
    }
}
```
### III.饿汉式(线程安全）
线程不安全问题主要是由于`instance`被实例化多次，采取直接实例化的方式











